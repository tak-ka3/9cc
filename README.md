# 9cc

## メモ
- 実際のx86-64はスタックマシンではなく、レジスタマシンなのでレジスタマシンでスタックマシンをエミュレートする必要がある
    - やり方としては、スタックマシンで一つの命令になっているものをレジスタマシンで複数の命令を使って実装すれば良い。
    - スタックポインタ：スタックの先頭の要素を指すレジスタ
    - x86-64ではRSPレジスタをスタックポイントとして使っている。pushやpopはRSPの値を変更しつつ、それが指すメモリにアクセスする
    - スタックとはどこのこと？メモリ？
    - 計算はあくまでレジスタ上で行われる

- x86-64では比較はフラグレジスタというものを用いて管理される。risc-vは値の比較の結果は普通のレジスタにセットされる。
    - cmp命令の実態は、特殊なsub命令で、sub命令だとraxに値の結果が代入されてしまうが、cmpにすることで、整数レジスタに値を書き込まずにすむ。

- リロケート：call命令で関数を呼ぶが、その時の飛び先のアドレスは分割コンパイルの時点ではわからない。とりあえずアセンブラはアドレス0に飛ぶようなcall命令を出力しておいて、オブジェクトファイル内に「オブジェクトファイルのXバイト目をYという名前の関数のアドレスで修正する」という情報を残しておく。リンカはその情報を見て実行ファイルのレイアウトを決めた後、プログラム断片をバイナリパッチングしてジャンプ先のアドレスを修正する。
- objdumpコマンドは、-Dオプションを渡すことでデータをコードとして無理矢理逆アセンブルすることができる。([参照](https://www.sigbus.info/compilerbook#%E3%82%B0%E3%83%AD%E3%83%BC%E3%83%90%E3%83%AB%E5%A4%89%E6%95%B0%E3%81%AE%E5%AE%A3%E8%A8%80%E3%81%A8%E5%AE%9A%E7%BE%A9))
- 関数も変数もアセンブリにおいてはただのラベルになっていて同じ名前空間に属しているので、どれが関数でどれがデータなのかは気にしない。つまり変数もまるで関数のようにコードとして実行することもできる。
